import * as BN from 'bn.js';
import { toB64, fromB64 } from './b64';
import { toHEX, fromHEX } from './hex';
export { toB64, fromB64, fromHEX, toHEX };
/**
 * Class used for reading BCS data chunk by chunk. Meant to be used
 * by some wrapper, which will make sure that data is valid and is
 * matching the desired format.
 *
 * @example
 * // data for this example is:
 * // { a: u8, b: u32, c: bool, d: u64 }
 *
 * let reader = new BcsReader("647f1a060001ffffe7890423c78a050102030405");
 * let field1 = reader.read8();
 * let field2 = reader.read32();
 * let field3 = reader.read8() == '1'; // bool
 * let field4 = reader.read64();
 * // ....
 *
 * Reading vectors is another deal in bcs. To read a vector, you first need to read
 * its length using {@link readULEB}. Here's an example:
 * @example
 * // data encoded: { field: [1, 2, 3, 4, 5] }
 * let reader = new BcsReader("050102030405");
 * let vec_length = reader.readULEB();
 * let elements = [];
 * for (let i = 0; i < vec_length; i++) {
 *   elements.push(reader.read8());
 * }
 * console.log(elements); // [1,2,3,4,5]
 *
 * @param {String} data HEX-encoded data (serialized BCS)
 */
export declare class BcsReader {
    private dataView;
    private bytePosition;
    /**
     * @param {Uint8Array} data Data to use as a buffer.
     */
    constructor(data: Uint8Array);
    /**
     * Shift current cursor position by `bytes`.
     *
     * @param {Number} bytes Number of bytes to
     * @returns {this} Self for possible chaining.
     */
    shift(bytes: number): this;
    /**
     * Read U8 value from the buffer and shift cursor by 1.
     * @returns
     */
    read8(): BN;
    /**
     * Read U16 value from the buffer and shift cursor by 2.
     * @returns
     */
    read16(): BN;
    /**
     * Read U32 value from the buffer and shift cursor by 4.
     * @returns
     */
    read32(): BN;
    /**
     * Read U64 value from the buffer and shift cursor by 8.
     * @returns
     */
    read64(): BN;
    /**
     * Read U128 value from the buffer and shift cursor by 16.
     * @returns
     */
    read128(): BN;
    /**
     * Read `num` number of bytes from the buffer and shift cursor by `num`.
     * @param num Number of bytes to read.
     * @returns Selected Buffer.
     */
    readBytes(num: number): Uint8Array;
    /**
     * Read ULEB value - an integer of varying size. Used for enum indexes and
     * vector lengths.
     * @returns {Number} The ULEB value.
     */
    readULEB(): number;
    /**
     * Read a BCS vector: read a length and then apply function `cb` X times
     * where X is the length of the vector, defined as ULEB in BCS bytes.
     * @param cb Callback to process elements of vector.
     * @returns {Array<Any>} Array of the resulting values, returned by callback.
     */
    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[];
}
/**
 * Class used to write BCS data into a buffer. Initializer requires
 * some size of a buffer to init; default value for this buffer is 1KB.
 *
 * Most methods are chainable, so it is possible to write them in one go.
 *
 * @example
 * let serialized = new BcsWriter()
 *   .write8(10)
 *   .write32(1000000)
 *   .write64(10000001000000)
 *   .hex();
 */
export declare class BcsWriter {
    private dataView;
    private bytePosition;
    /**
     * @param {Number} [size=1024] Size of the buffer to reserve for serialization.
     */
    constructor(size?: number);
    /**
     * Unify argument types by converting them to BN.
     */
    static toBN(number: number | BN | bigint | string): BN;
    /**
     * Shift current cursor position by `bytes`.
     *
     * @param {Number} bytes Number of bytes to
     * @returns {this} Self for possible chaining.
     */
    shift(bytes: number): this;
    /**
     * Write a U8 value into a buffer and shift cursor position by 1.
     * @param {Number} value Value to write.
     * @returns {this}
     */
    write8(value: number | bigint | BN): this;
    /**
     * Write a U16 value into a buffer and shift cursor position by 2.
     * @param {Number} value Value to write.
     * @returns {this}
     */
    write16(value: number | bigint | BN): this;
    /**
     * Write a U32 value into a buffer and shift cursor position by 4.
     * @param {Number} value Value to write.
     * @returns {this}
     */
    write32(value: number | bigint | BN): this;
    /**
     * Write a U64 value into a buffer and shift cursor position by 8.
     * @param {bigint} value Value to write.
     * @returns {this}
     */
    write64(value: bigint | BN): this;
    /**
     * Write a U128 value into a buffer and shift cursor position by 16.
     *
     * @unimplemented
     * @param {bigint} value Value to write.
     * @returns {this}
     */
    write128(value: bigint | BN): this;
    /**
     * Write a ULEB value into a buffer and shift cursor position by number of bytes
     * written.
     * @param {Number} value Value to write.
     * @returns {this}
     */
    writeULEB(value: number): this;
    /**
     * Write a vector into a buffer by first writing the vector length and then calling
     * a callback on each passed value.
     *
     * @param {Array<Any>} vector Array of elements to write.
     * @param {WriteVecCb} cb Callback to call on each element of the vector.
     * @returns {this}
     */
    writeVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => {}): this;
    /**
     * Adds support for iterations over the object.
     * @returns {Uint8Array}
     */
    [Symbol.iterator](): Iterator<number, Iterable<number>>;
    /**
     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
     * @returns {Uint8Array} Resulting bcs.
     */
    toBytes(): Uint8Array;
    /**
     * Represent data as 'hex' or 'base64'
     * @param encoding Encoding to use: 'base64' or 'hex'
     */
    toString(encoding: string): string;
}
/**
 * Set of methods that allows data encoding/decoding as standalone
 * BCS value or a part of a composed structure/vector.
 */
export interface TypeInterface {
    encode: (data: any, size: number) => BcsWriter;
    decode: (data: Uint8Array) => any;
    _encodeRaw: (writer: BcsWriter, data: any) => BcsWriter;
    _decodeRaw: (reader: BcsReader) => any;
}
/**
 * BCS implementation for Move types and few additional built-ins.
 */
export declare class bcs {
    static readonly U8: string;
    static readonly U32: string;
    static readonly U64: string;
    static readonly U128: string;
    static readonly BOOL: string;
    static readonly VECTOR: string;
    static readonly ADDRESS: string;
    static readonly STRING: string;
    static types: Map<string, TypeInterface>;
    /**
     * Serialize data into bcs.
     *
     * @example
     * bcs.registerVectorType('vector<u8>', 'u8');
     *
     * let serialized = BCS
     *   .set('vector<u8>', [1,2,3,4,5,6])
     *   .toBytes();
     *
     * console.assert(toHex(serialized) === '06010203040506');
     *
     * @param type Name of the type to serialize (must be registered).
     * @param data Data to serialize.
     * @param size Serialization buffer size. Default 1024 = 1KB.
     * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
     */
    static ser(type: string, data: any, size?: number): BcsWriter;
    /**
     * Deserialize BCS into a JS type.
     *
     * @example
     * let num = bcs.ser('u64', '4294967295').toString('hex');
     * let deNum = bcs.de('u64', num, 'hex');
     * console.assert(deNum.toString(10) === '4294967295');
     *
     * @param type Name of the type to deserialize (must be registered).
     * @param data Data to deserialize.
     * @param encoding Optional - encoding to use if data is of type String
     * @return Deserialized data.
     */
    static de(type: string, data: Uint8Array | string, encoding?: string): any;
    /**
     * Check whether a TypeInterface has been loaded for the `Type`
     * @param type Name of the type to check.
     * @returns
     */
    static hasType(type: string): boolean;
    /**
     * Method to register new types for BCS internal representation.
     * For each registered type 2 callbacks must be specified and one is optional:
     *
     * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
     * - decodeCb(reader) - write a way to deserialize data with BcsReader;
     * - validateCb(data) - validate data - either return bool or throw an error
     *
     * @example
     * // our type would be a string that consists only of numbers
     * bcs.registerType('number_string',
     *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
     *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
     *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
     * );
     * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
     *
     * @param name
     * @param encodeCb Callback to encode a value.
     * @param decodeCb Callback to decode a value.
     * @param validateCb Optional validator Callback to check type before serialization.
     */
    static registerType(name: string, encodeCb: (writer: BcsWriter, data: any) => BcsWriter, decodeCb: (reader: BcsReader) => any, validateCb?: (data: any) => boolean): typeof bcs;
    /**
     * Register an address type which is a sequence of U8s of specified length.
     * @example
     * bcs.registerAddressType('address', 20);
     * let addr = bcs.de('address', 'ca27601ec5d915dd40d42e36c395d4a156b24026');
     *
     * @param name Name of the address type.
     * @param length Byte length of the address.
     * @param encoding Encoding to use for the address type
     * @returns
     */
    static registerAddressType(name: string, length: number, encoding?: string | void): typeof bcs;
    /**
     * Register custom vector type inside the bcs.
     *
     * @example
     * bcs.registerVectorType('vector<u8>', 'u8');
     * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
     * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
     *
     * @param name Name of the type to register
     * @param elementType Name of the inner type of the vector
     * @return Returns self for chaining.
     */
    static registerVectorType(name: string, elementType: string): typeof bcs;
    /**
     * Safe method to register a custom Move struct. The first argument is a name of the
     * struct which is only used on the FrontEnd and has no affect on serialization results,
     * and the second is a struct description passed as an Object.
     *
     * The description object MUST have the same order on all of the platforms (ie in Move
     * or in Rust).
     *
     * @example
     * // Move / Rust struct
     * // struct Coin {
     * //   value: u64,
     * //   owner: vector<u8>, // name // Vec<u8> in Rust
     * //   is_locked: bool,
     * // }
     *
     * bcs.registerStructType('Coin', {
     *   value: bcs.U64,
     *   owner: bcs.STRING,
     *   is_locked: bcs.BOOL
     * });
     *
     * // Created in Rust with diem/bcs
     * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
     * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
     *  128, 209, 177,   5,  96,  0,  0,
     *    0,  14,  66, 105, 103, 32, 87,
     *   97, 108, 108, 101, 116, 32, 71,
     *  117, 121,   0
     * ];
     *
     * // Let's encode the value as well
     * let test_set = bcs.ser('Coin', {
     *   owner: 'Big Wallet Guy',
     *   value: '412412400000',
     *   is_locked: false,
     * });
     *
     * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
     *
     * @param name Name of the type to register.
     * @param fields Fields of the struct. Must be in the correct order.
     * @return Returns BCS for chaining.
     */
    static registerStructType(name: string, fields: {
        [key: string]: string;
    }): typeof bcs;
    /**
     * Safe method to register custom enum type where each invariant holds the value of another type.
     * @example
     * bcs.registerStructType('Coin', { value: 'u64' });
     * bcs.registerVectorType('vector<Coin>', 'Coin');
     * bcs.registerEnumType('MyEnum', {
     *  single: 'Coin',
     *  multi: 'vector<Coin>'
     * });
     *
     * console.log(
     *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
     *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
     * )
     *
     * // and serialization
     * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
     * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
     *
     * @param name
     * @param variants
     */
    static registerEnumType(name: string, variants: {
        [key: string]: string | null;
    }): typeof bcs;
    /**
     * Get a set of encoders/decoders for specific type.
     * Mainly used to define custom type de/serialization logic.
     *
     * @param type
     * @returns {TypeInterface}
     */
    static getTypeInterface(type: string): TypeInterface;
}
/**
 * Encode data with either `hex` or `base64`.
 *
 * @param {Uint8Array} data Data to encode.
 * @param {String} encoding Encoding to use: base64 or hex
 * @return {String} Encoded value.
 */
export declare function encodeStr(data: Uint8Array, encoding: string): string;
/**
 * Decode either `base64` or `hex` data.
 *
 * @param {String} data Data to encode.
 * @param {String} encoding Encoding to use: base64 or hex
 * @return {Uint8Array} Encoded value.
 */
export declare function decodeStr(data: string, encoding: string): Uint8Array;
